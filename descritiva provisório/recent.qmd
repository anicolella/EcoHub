---
title: "analise recorte recente"
format: html
---
## Justificativa
Tendo em vista a heterogeniedade dos gráficos demonstrada na página "principal", busca-se aqui fazer uma análise mais completa do cenário brasileiro para o mercado de terras se utilizando de valores unificados para um único ano com maior disponibilidade dos dados e correção inflacionária dos municípios que não estão presentes no referente ano, neste caso 2023.

```{r}
#| echo: false
#| message: false
#| warning: false
#| include: false

library(tidyverse)
library(geobr)
library(ipeadatar)
library(stringr)
library(readr)
library(sf)
library(gtsummary)
library(gt)
library(plotly)
library(htmltools)

df_analise <- st_read(
  dsn   = "C:/Users/jodom/OneDrive/Área de Trabalho/proxy_classificado.gpkg",
  layer = "df_classificado",
  quiet = TRUE   # ou o nome de camada que você usou no st_write
)

df_areas <- df_analise |>
  mutate(
    # 1. Calcula a área (retorna em m^2 [units])
    area_m2 = st_area(geom),
    
    # 2. Converte para Hectares e remove o tipo 'units' para evitar erros em gráficos
    area_ha_calculada = as.numeric(area_m2) / 10000
  )

 df_joined <- df_analise 
```

<<<<<<< HEAD
A correção inflacionária foi feita para o ano de 2023, utilzando-se do índice IGPDI anual, com uso das séries de tempo referentes a API do IPEA.
=======
A correção inflacionária foi alterada para o ano de 2023, seguindo o código:
>>>>>>> a6584ea4282af447af8f93ba870ae189becefe3d
```{r}
#| echo: false
#| message: false
#| warning: false
#| eval: false
library(dplyr)
library(lubridate)
library(ipeadatar)

indice_raw <- ipeadata(code = "IGP_IGPDIG", language = "br")

tabela_indices <- indice_raw %>%
  mutate(
    ano = year(as.Date(date)),
    # Transforma taxa percentual em fator multiplicativo (ex: 0.5% vira 1.005)
    fator_mensal = (value / 100) + 1
  ) %>%
  # Agrupa para obter a inflação anualizada
  group_by(ano) %>%
  summarise(
    fator_anual = prod(fator_mensal, na.rm = TRUE), 
    .groups = "drop"
  ) %>%
  arrange(ano) %>%
  # --- AQUI ESTÁ A CORREÇÃO QUE VOCÊ PEDIU ---
  # O índice do ano X é o produto de tudo que veio antes (acumulado)
  mutate(indice_acumulado = cumprod(fator_anual))

# Extrai o índice acumulado EXATAMENTE do ano de 2024.
# O 'pull' transforma o dataframe de 1 célula em um valor numérico puro (vector).
indice_base_2023 <- tabela_indices %>%
  filter(ano == 2023) %>%
  pull(indice_acumulado)

# CHECK DE SEGURANÇA (Defensive Programming)
if(length(indice_base_2023) == 0) stop("ERRO CRÍTICO: Ano de 2024 não encontrado na base do IPEA.")

#### 3. Cruzamento e Cálculo ####
resultado_igpdi <- df_joined %>%
  mutate(ano = as.numeric(ano)) %>% 
  left_join(tabela_indices, by = "ano") %>%
  mutate(
    # FATOR DE CORREÇÃO (Deflacionamento):
    # Fórmula: Valor_Real = Valor_Nominal * (Indice_Base / Indice_Corrente)
    # Aqui trazemos tudo para o poder de compra de 2024.
    fator_deflator = indice_base_2023 / indice_acumulado,
    
    across(
      c("vti_media", "vti_minimo", "vti_maximo", "vtn_media", "vtn_minimo", "vtn_maximo"), 
      ~ .x * fator_deflator, 
      .names = "IGPDI_{.col}"
    )
  ) %>%
  select(colnames(df_joined), starts_with("IGPDI_"))

```

Os dados posteriormente foram separados para aqueles mais próximos do ano de 2023, com o critério de desempate sendo os dados com o ano mais atualizado:

```{r}
#| message: false
#| warning: false
#| eval: false
#| echo: false 
resultado_2023_proxy <- resultado_igpdi %>%
  # 1. Define o escopo de comparação (por cidade)
  group_by(code_muni) %>%
  
  # 2. Calcula a "distância temporal" para cada registro
  mutate(delta_tempo = abs(ano - 2023)) %>%
  
  # 3. Filtro em dois estágios para garantir a melhor escolha:
  
  # Estágio A: Fica apenas com os anos que têm a menor distância absoluta
  filter(delta_tempo == min(delta_tempo)) %>%
  
  # Estágio B: Critério de Desempate (Tie-breaker)
  # Se uma cidade tiver dados de 2022 e 2024 (ambos delta=1),
  # escolhemos o mais recente (2024) por conter informação mais atualizada.
  filter(ano == max(ano)) %>%
  
  # 4. Limpeza
  ungroup() %>%
  select(-delta_tempo)
```

<<<<<<< HEAD
Encontra-se a seguinte disponibilidade de dados, em verde os dados atualmente disponíveis com o recorte temporal mais completo possível, enquanto em vermelho são aqueles municípios sem observação presente. O ano do mapa utilizado foi de 2020, usando a API do IBGE.
=======
disponibilidade total dos dados:
>>>>>>> a6584ea4282af447af8f93ba870ae189becefe3d

```{r}
library(geobr)
library(ggplot2)
library(dplyr)
library(sf)

# 1. Baixar a Malha Municipal Oficial (O "Tabuleiro" completo)
# Usamos 2020 ou 2022 para garantir compatibilidade com a maioria das bases históricas
mapa_base <- read_municipality(year = 2020, showProgress = FALSE)

# 2. Preparar seus dados para o confronto
# Importante: Removemos a geometria do seu df para evitar duplicidade ou erro no join
<<<<<<< HEAD
dados_existentes <- df_analise %>% # Ou use resultado_igpdi se preferir
=======
dados_existentes <- resultado_2023_proxy %>% # Ou use resultado_igpdi se preferir
>>>>>>> a6584ea4282af447af8f93ba870ae189becefe3d
  st_drop_geometry() %>% # Garante que vira um tibble puro, sem geometria
  select(code_muni) %>% 
  distinct() %>% 
  mutate(status = "Disponível")

# 3. Cruzamento: Quem está no mapa oficial vs. Quem está na sua base
mapa_diagnostico <- mapa_base %>%
  mutate(code_muni = as.numeric(code_muni)) %>% 
  left_join(dados_existentes, by = "code_muni") %>%
  mutate(
    # Se não deu match, é "Ausente"
    status = ifelse(is.na(status), "Ausente", status)
  )

<<<<<<< HEAD
mapa_diagnostico_light <- mapa_diagnostico %>%
  st_simplify(dTolerance = 0.01, preserveTopology = TRUE)

# 1. Plotagem Adaptada para Interatividade
p <- ggplot(data = mapa_diagnostico_light) +
  geom_sf(aes(fill = status, 
              # O 'text' define o que aparece no hover do mouse
              text = paste0("Município: ", name_muni, "\n",
                            "Código: ", code_muni, "\n",
                            "Status: ", status)), 
          color = NA, size = 0.05) + # size reduzido para limpar bordas
  
  scale_fill_manual(values = c("Disponível" = "#0c7700ff", 
                               "Ausente" = "#ff0000ff")) +
  
  theme_void() +
  labs(title = "Auditoria Interativa: Cobertura Espacial")

# 2. Conversão (O Pulo do Gato)
# tooltip = "text" garante que só mostre o que configuramos acima, limpando o ruído de lat/long
figura_interativa <- ggplotly(p, tooltip = "text")

# 3. Execução
figura_interativa
```

As observações variam de acordo com a quantidade de cada tipologia, a quantidade de observações para cada tipologia foi a seguinte:

```{r}
library(plotly)
library(forcats)
library(dplyr)

dados_plot <- if(inherits(df_analise, "sf")) sf::st_drop_geometry(df_analise) else df_analise

dados_plot <- dados_plot %>%
  mutate(
    # Ao nomear a coluna como 'Categoria', o tooltip mostrará "Categoria: [valor]"
    Categoria = fct_rev(fct_infreq(as.factor(categoria_final)))
  )

# 2. Construção do Objeto Gráfico (Frontend)
p <- ggplot(dados_plot, aes(x = Categoria, fill = Categoria)) + 
  geom_bar(show.legend = FALSE) +
  
  coord_flip() + 
  
  labs(
    title = "Contagem por Categoria Final",
    x = NULL,
    y = "Total de Observações"
  ) +
  
  theme_minimal() + 
  
  theme(
    axis.text.y = element_text(face = "bold", size = 10),
    axis.text.x = element_text(face = "bold")            
  )

# 3. Conversão Cirúrgica
# tooltip = c("x", "y") força o plotly a mostrar apenas as variáveis dos eixos,
# ignorando metadados residuais.
ggplotly(p, tooltip = c("x", "y"))
```

## 3. Análise e distribuições
A estatística descritiva revela uma oscilação expressiva nos valores de VTI e VTN ao longo da série histórica. Essa volatilidade não reflete necessariamente uma tendência de mercado, mas sim a heterogeneidade espacial da coleta de dados em cada exercício. A tabela a seguir consolida as métricas de tendência central (média) e dispersão (mínimos e máximos) para ambas as categorias.

mostra a disponibilidade de dados para 23 e oq foi usado para atualizar.
```{r}
library(gt)
library(dplyr)
library(sf)

# 1. Preparar os dados (Agregação Ponderada)
tabela_pivo <- df_areas |>
  st_drop_geometry() |>
  group_by(ano) |>
  summarise(
    # --- VTI: Ponderado pela Área ---
    vti_med = weighted.mean(vti_media, w = area_ha_calculada, na.rm = TRUE),
    vti_min = min(vti_minimo, na.rm = TRUE),
    vti_max = max(vti_maximo, na.rm = TRUE),
    
    # --- VTN: Ponderado pela Área ---
    vtn_med = weighted.mean(vtn_media, w = area_ha_calculada, na.rm = TRUE),
    vtn_min = min(vtn_minimo, na.rm = TRUE),
    vtn_max = max(vtn_maximo, na.rm = TRUE),
    
    # --- Auditoria ---
    n_registros = n_distinct(origem)
  )

# 2. Gerar a Tabela Profissional
tabela_pivo |>
  gt() |>
  
  # --- Cabeçalho ---
  tab_header(
    title = md("**Evolução Histórica de Preços (VTI vs VTN)**"),
    subtitle = "Média Ponderada por Área (ha) e Amplitude"
  ) |>
  
  # --- Formatação Numérica ---
  fmt_number(
    columns = -ano,
    decimals = 0,
    sep_mark = ".",
    dec_mark = ","
  ) |>
  
  # --- Fusão (Merge) ---
  cols_merge(
    columns = c(vti_med, vti_min, vti_max),
    pattern = "{1} ({2} - {3})"
  ) |>
  cols_merge(
    columns = c(vtn_med, vtn_min, vtn_max),
    pattern = "{1} ({2} - {3})"
  ) |>
  
  # --- Labels ---
  cols_label(
    ano = "Ano",
    vti_med = md("**VTI (R$/ha)**<br><small>Média (Mín - Máx)</small>"),
    vtn_med = md("**VTN (R$/ha)**<br><small>Média (Mín - Máx)</small>"),
    n_registros = "Nº Municípios"
  ) |>
  
  # --- Estilo ---
  # Ajuste Tático: Ano centralizado, Números à direita (padrão financeiro)
  cols_align(align = "center", columns = ano) |>
  cols_align(align = "right", columns = -ano) |> 
  
  opt_row_striping() |>
  tab_options(
    table.width = pct(100),
    data_row.padding = px(6)
  )
```

Segue uma tabela do valor de terra por quantil ao longo de toda a amostragem, lembrando que os valores aqui apresentados são fruto de correções inflacionárias de todos os valores para o ano de 2023. 

```{r}
#| message: false
#| warning: false

# 1. Cálculo dos Quantis por Categoria
tabela_quantis <- df_areas |>
  st_drop_geometry() |>
  filter(!is.na(vti_media), vti_media > 0) |>
  group_by(categoria_final) |>
  summarise(
    N = n(),
    # Calcula os cortes de preço que dividem o mercado
    P10 = quantile(vti_media, 0.10),
    P25 = quantile(vti_media, 0.25),
    Mediana = median(vti_media),
    P75 = quantile(vti_media, 0.75),
    P90 = quantile(vti_media, 0.90)
  ) |>
  arrange(desc(Mediana)) # Ordena do mais caro para o mais barato

# 2. Renderização da Tabela
tabela_quantis |>
  gt() |>
  tab_header(
    title = md("**Estrutura de Preços: Distribuição por Quantis**"),
    subtitle = "Valores de Terra (VTI) em R$/ha"
  ) |>
  fmt_number(
    columns = c(P10, P25, Mediana, P75, P90),
    decimals = 0,
    sep_mark = ".",
    dec_mark = ","
  ) |>
  cols_label(
    categoria_final = "Categoria",
    N = "Amostras",
    P10 = "Piso (10%)",
    P25 = "Baixo (25%)",
    Mediana = "Médio (50%)",
    P75 = "Alto (75%)",
    P90 = "Teto (90%)"
  ) |>
  # Destaque visual para a Mediana (o valor mais provável)
  tab_style(
    style = list(
      cell_text(weight = "bold", color = "black"),
      cell_fill(color = "lightgray")
    ),
    locations = cells_body(columns = Mediana)
  ) |>
  data_color(
    columns = c(Mediana),
    method = "numeric",
    palette = "Greens" # Escala de cor para mostrar quem vale mais
  )
```

Geograficamente, os dados refletem uma estrutura que respeita o esperado: os estados das regiões Sul, Sudeste e Centro-Oeste apresentam um maior valor para a terra com imóvel, enquanto as regiões Norte e Nordeste apresentam valores inferiores. Uma anomalia que se encontra é a região de Manaus, que compõe a Zona Homogênea de Terras 'Manaus e Entorno'. Os valores dos imóveis provavelmente aumentam por conta da pressão da zona urbana, como é o caso típico de imóveis apresentando maior valor em áreas altamente urbanizadas.


```{r}
library(dplyr)
library(ggplot2)
library(sf)
library(scales)
library(stringr)

# 1. Definição do Escopo
categorias_alvo <- c("agricultura", "pecuaria", "media geral", "exploracao mista", "vegetacao nativa")
lista_plots <- list()

# 2. Execução Iterativa
for(cat in categorias_alvo) {
  
  # A. Filtragem
  dados_cat <- df_analise |>
    filter(ano < 2025, !is.na(vti_media), vti_media > 0) |>
    filter(categoria_final == cat) |> 
    group_by(code_muni) |>
    slice_max(order_by = ano, n = 1) |> 
    ungroup()
  
  # B. Gera os intervalos brutos
  # dig.lab = 15 força números inteiros (sem 1e+05)
  dados_cat <- dados_cat |>
    mutate(
      classe_raw = cut_number(vti_media, n = 5, dig.lab = 15),
      classe_preco = classe_raw # Cria cópia para modificar os níveis
    )

  # --- C. O TRATAMENTO DE STRING (Regex) ---
  # Pega os níveis originais: ex: "(100, 500]"
  niveis_originais <- levels(dados_cat$classe_preco)
  
  # 1. Remove colchetes e parênteses
  niveis_limpos <- str_remove_all(niveis_originais, "[\\(\\]\\[\\)]")
  
  # 2. Substitui a vírgula por " - "
  niveis_limpos <- str_replace(niveis_limpos, ",", " - ")
  
  # 3. Aplica os rótulos finais (Qualitativo + Intervalo Limpo)
  levels(dados_cat$classe_preco) <- paste0(
    c("Muito Baixo", "Baixo", "Médio", "Alto", "Muito Alto"), 
    "\n", 
    niveis_limpos # Resultado: "100 - 500"
  )

  # D. Plotagem Estática
  p <- ggplot(dados_cat) +
    geom_sf(aes(fill = classe_preco), color = NA, lwd = 0) +
    
    scale_fill_brewer(
      palette = "Spectral", 
      direction = -1,
      name = "Faixa de Preço (R$/ha)"
    ) +
    
    labs(
      title = paste("Panorama VTI:", toupper(cat)),
      subtitle = "Distribuição de Preços Relativa (Quantis)",
      x = NULL, y = NULL
    ) +
    
    theme_void() +
    theme(
      plot.title = element_text(face = "bold", size = 14),
      legend.position = "right",
      legend.key.height = unit(0.8, "cm"), # Altura ajustada para 2 linhas
      legend.text = element_text(size = 9)
    )

  lista_plots[[cat]] <- p
  message(paste("Processado:", cat))
  print(p)
}

```

para os valores do VTN:

```{r}
library(dplyr)
library(ggplot2)
library(sf)
library(scales)
library(stringr)

# 1. Definição do Escopo
categorias_alvo <- c("agricultura", "pecuaria", "media geral", "exploracao mista", "vegetacao nativa")
lista_plots <- list()

# 2. Execução Iterativa
for(cat in categorias_alvo) {
  
  # A. Filtragem
  dados_cat <- df_analise |>
    filter(ano < 2025, !is.na(vtn_media), vtn_media > 0) |>
    filter(categoria_final == cat) |> 
    group_by(code_muni) |>
    slice_max(order_by = ano, n = 1) |> 
    ungroup()
  
  # B. Gera os intervalos brutos
  # dig.lab = 15 força números inteiros (sem 1e+05)
  dados_cat <- dados_cat |>
    mutate(
      classe_raw = cut_number(vtn_media, n = 5, dig.lab = 15),
      classe_preco = classe_raw # Cria cópia para modificar os níveis
    )

  # --- C. O TRATAMENTO DE STRING (Regex) ---
  # Pega os níveis originais: ex: "(100, 500]"
  niveis_originais <- levels(dados_cat$classe_preco)
  
  # 1. Remove colchetes e parênteses
  niveis_limpos <- str_remove_all(niveis_originais, "[\\(\\]\\[\\)]")
  
  # 2. Substitui a vírgula por " - "
  niveis_limpos <- str_replace(niveis_limpos, ",", " - ")
  
  # 3. Aplica os rótulos finais (Qualitativo + Intervalo Limpo)
  levels(dados_cat$classe_preco) <- paste0(
    c("Muito Baixo", "Baixo", "Médio", "Alto", "Muito Alto"), 
    "\n", 
    niveis_limpos # Resultado: "100 - 500"
  )

  # D. Plotagem Estática
  p <- ggplot(dados_cat) +
    geom_sf(aes(fill = classe_preco), color = NA, lwd = 0) +
    
    scale_fill_brewer(
      palette = "Spectral", 
      direction = -1,
      name = "Faixa de Preço (R$/ha)"
    ) +
    
    labs(
      title = paste("Panorama VTN:", toupper(cat)),
      subtitle = "Distribuição de Preços Relativa (Quantis)",
      x = NULL, y = NULL
    ) +
    
    theme_void() +
    theme(
      plot.title = element_text(face = "bold", size = 14),
      legend.position = "right",
      legend.key.height = unit(0.8, "cm"), # Altura ajustada para 2 linhas
      legend.text = element_text(size = 9)
    )

  lista_plots[[cat]] <- p
  message(paste("Processado:", cat))
  print(p)
}

```

A análise das linhas de densidade demonsrea um comportamento de multimodalidade para todas as categorias na distribuição dos preços. Apresentando notavelmente uma quantidade mais acentuada de picos e vales nas nomenclaturas categóricas: "pecuária", "agricultura" e vegetação nativa. 

Estatisticamente, a existência de múltiplos picos (modas) sugere a coexistência de submercados distintos sob a mesma rotulagem. No caso da Pecuária, a trimodalidade observada indica uma segmentação tecnológica e geográfica severa. Isso pode ser efeito da unificação tipologica para fins de análise.


```{r}
library(plotly)
library(dplyr)
library(ggplot2)
library(scales)

# 1. Preparação dos Dados (Mantida)
dados_hist <- if(inherits(df_analise, "sf")) sf::st_drop_geometry(df_analise) else df_analise

dados_hist <- dados_hist |>
  filter(vti_media > 0, vtn_media > 0) |>
  filter(categoria_final %in% c("agricultura", "pecuaria", "media geral", 
                                "exploracao mista", "silvicultura", "vegetacao nativa"))

# 2. A Ferramenta Corrigida (Log no Backend)
gerar_distribuicao_ajustada <- function(dados, var_col, titulo_main) {
  
  # A. Captura a variável (tidyeval)
  var_sym <- rlang::ensym(var_col)
  
  # B. TRANSFORMAÇÃO PRÉVIA (O Segredo)
  # Criamos o log explicitamente no dataframe.
  # Isso estabiliza a variância para o geom_density funcionar liso.
  dados_temp <- dados |>
    mutate(
      valor_log = log10(!!var_sym),
      valor_real = !!var_sym # Mantemos o original para o tooltip
    )
  
  # C. Construção do Gráfico
  p <- ggplot(dados_temp, aes(x = valor_log)) +
    
    # Histograma (Baseado no Log)
    geom_histogram(
      aes(
        y = after_stat(density), 
        fill = categoria_final,
        # Tooltip recupera o valor em Reais para o usuário não ver "Log=4.5"
        text = paste0(
          "Valor Aprox: ", scales::dollar(10^after_stat(x), prefix = "R$ ", accuracy = 1), "\n",
          "Densidade: ", round(after_stat(density), 2)
        )
      ), 
      color = "white", 
      alpha = 0.4, 
      bins = 40, # Bins fixos no espaço log ficam visualmente agradáveis
      show.legend = FALSE
    ) +
    
    # Linha de Densidade (Agora ficará lisa pois os dados são "Normais" no Log)
    geom_density(
      color = "#2c3e50", 
      size = 0.8, 
      adjust = 1.2 # Ajuste fino da suavização
    ) +
    
    # D. "Engenharia Social" do Eixo X
    # O eixo é log, mas mostramos os rótulos em Dinheiro (Anti-Log)
    scale_x_continuous(
      breaks = log10(c(1000, 5000, 10000, 50000, 100000, 500000)),
      labels = c("1k", "5k", "10k", "50k", "100k", "500k")
    ) +
    
    facet_wrap(~categoria_final, scales = "free_y") +
    
    labs(
      title = titulo_main,
      subtitle = "Suavização Kernel sobre Domínio Log-Linearizado",
      x = "Valor da Terra (R$/ha)",
      y = "Densidade (Probabilidade)"
    ) +
    
    theme_minimal() +
    theme(
      strip.text = element_text(face = "bold", size = 11),
      axis.text.x = element_text(angle = 0, hjust = 0.5)
    )

  ggplotly(p, tooltip = "text") 
}

# 3. Executar
plot_vti <- gerar_distribuicao_ajustada(dados_hist, vti_media, "Distribuição VTI (Ajustada)")
plot_vti
```


```{r}
# Execução para VTN (Valor da Terra Nua)
plot_vtn <- gerar_distribuicao_ajustada(
  dados = dados_hist, 
  var_col = vtn_media, # <--- A única mudança ocorre aqui
  titulo_main = "Distribuição VTN (Log-Normal Ajustada)"
)

plot_vtn
```




```{r}
library(plotly)
library(dplyr)
library(tidyr)
library(ggplot2)

# 1. Preparação (Wide -> Long)
dados_box <- if(inherits(df_analise, "sf")) sf::st_drop_geometry(df_analise) else df_analise

dados_comparativos <- dados_box |>
  filter(vti_media > 0, vtn_media > 0) |>
  filter(categoria_final %in% c("agricultura", "pecuaria", "media geral", "exploracao mista", "silvicultura", "vegetacao nativa")) |>
  select(categoria_final, vti_media, vtn_media) |>
  pivot_longer(
    cols = c(vti_media, vtn_media),
    names_to = "tipo_valor",
    values_to = "valor_ha"
  ) |>
  mutate(
    tipo_valor = factor(tipo_valor, 
      levels = c("vti_media", "vtn_media"), 
      labels = c("VTI (Com Imóvel)", "VTN (Terra Nua)"))
  )

# 2. O Plot Base
p1 <- ggplot(dados_comparativos, aes(x = reorder(categoria_final, valor_ha, FUN = median), y = valor_ha, fill = tipo_valor)) +
  
  geom_boxplot(
    outlier.alpha = 0.3, 
    outlier.size = 0.5,
    # O Plotly ignora outlier.color na conversão as vezes, mas mantemos pro ggplot
    outlier.color = "gray40" 
  ) +
  
  scale_y_log10(
    labels = scales::label_number(prefix = "R$ ", scale_cut = scales::cut_short_scale()),
    breaks = c(1000, 5000, 10000, 50000, 100000, 500000)
  ) +
  
  scale_fill_manual(values = c("VTI (Com Imóvel)" = "#E69F00", "VTN (Terra Nua)" = "#56B4E9")) +
  
  coord_flip() + 
  
  labs(
    title = "Dispersão de Preços: Spread VTI vs. VTN",
    x = NULL,
    y = "Valor por Hectare (Log)",
    fill = "Métrica"
  ) +
  
  theme_minimal() +
  theme(
    legend.position = "top",
    axis.text.y = element_text(face = "bold", size = 10),
    panel.grid.major.y = element_blank()
  )

# 3. Conversão Interativa
# layout(boxmode = 'group') garante que as caixas fiquem lado a lado bonito
ggplotly(p1) |> layout(boxmode = "group")
```



```{r}
# 1. Preparação
dados_uf <- if(inherits(df_analise, "sf")) sf::st_drop_geometry(df_analise) else df_analise

dados_uf <- dados_uf |>
  filter(vti_media > 0) |>
  filter(categoria_final %in% c("agricultura", "pecuaria", "silvicultura", "vegetacao nativa", "exploracao mista")) |>
  # Lógica de extração de UF robusta
  mutate(
    UF = if("UF" %in% names(dados_uf)) UF else substr(code_muni, 1, 2)
  )

# 2. O Plot Base
p2 <- ggplot(dados_uf, aes(x = reorder(UF, vti_media, FUN = median), y = vti_media)) +
  
  geom_boxplot(
    aes(fill = categoria_final), 
    outlier.size = 0.5, 
    outlier.alpha = 0.3, 
    show.legend = FALSE
  ) +
  
  scale_y_log10(
    labels = scales::label_number(prefix = "R$ ", scale_cut = scales::cut_short_scale()),
    breaks = c(1000, 10000, 50000, 100000, 500000)
  ) +
  
  # scales = "free_y" no coord_flip (ou free_x no cartesiano) permite 
  # que cada gráfico tenha seu tamanho ideal
  facet_wrap(~categoria_final, scales = "free", ncol = 2) +
  
  coord_flip() + 
  
  labs(
    title = "Hierarquia de Valor: Ranking Estadual",
    x = NULL,
    y = "Valor da Terra (R$/ha) [Log]"
  ) +
  
  theme_minimal() +
  theme(
    strip.text = element_text(face = "bold", size = 11),
    axis.text.y = element_text(size = 6) # Fonte reduzida para caber 27 UFs
  )

# 3. Conversão
# Ajustamos a altura/largura se necessário, mas o padrão costuma funcionar bem
ggplotly(p2)
```

=======
# 4. Plotagem de Auditoria
ggplot(data = mapa_diagnostico) +
  # Camada única colorida pelo status
  geom_sf(aes(fill = status), color = NA) + 
  
  # Cores de Alto Contraste: Cinza Escuro (Dados OK) vs Vermelho Vivo (Problema)
  scale_fill_manual(values = c("Disponível" = "#0026ff78", "Ausente" = "#ff0000ff")) +
  
  theme_void() + # Remove eixos e poluição visual
  labs(
    title = "Auditoria de Cobertura Espacial",
    subtitle = paste0("Ausentes: ", sum(mapa_diagnostico$status == "Ausente"), 
                      " municípios (Vermelho)"),
    caption = "Atenção: Clusters vermelhos na fronteira da Amazônia invalidam o RDD."
  )
```
>>>>>>> a6584ea4282af447af8f93ba870ae189becefe3d
